<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>.DS_Store泄漏</title>
    <url>/2022/03/24/DS-Store%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h1 id="泄漏起因"><a href="#泄漏起因" class="headerlink" title="泄漏起因"></a>泄漏起因</h1><p>起因在于我把博客的图床的back cup由win迁移至了macos，重新上传时图方便采用了<code>add .</code>命令，而后在github中发现了.DS_Store文件</p>
<span id="more"></span>

<h1 id="DS-Store文件是什么"><a href="#DS-Store文件是什么" class="headerlink" title=".DS_Store文件是什么"></a>.DS_Store文件是什么</h1><p>DS_Store 全称 Desktop Service Store,即桌面服务存储，是一种由macOS系统创建的隐藏文件，用于保存文件夹自定义的属性如图标位置或背景色等，类比于win下的desktop.ini。</p>
<p>DS文件存储了文件相关的信息，这使得它有可能因此造成文件目录结构泄漏或是源代码或其他敏感信息的泄漏，这些泄漏可以被当作攻击手段,如<a href="https://blog.csdn.net/qq_45521281/article/details/105774453">基于DS_Store的安全问题</a></p>
<h1 id="如何防治"><a href="#如何防治" class="headerlink" title="如何防治"></a>如何防治</h1><p>目前来看，ds文件主要会因为两个途径泄漏</p>
<ul>
<li><p>与别人互换文件时</p>
<p>可以通过禁止全局的ds文件生成来源头性的避免ds文件的泄漏</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用git等工具进行开发时</p>
<p>采用全局性的.gitignore</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo .DS_Store &gt;&gt; ~/.gitignore_global</span><br><span class="line">git config --global core.excludesfile ~/.gitignore_global</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>R</title>
    <url>/2022/04/04/R/</url>
    <content><![CDATA[<p>R 语言是为数学研究工作者设计的一种数学编程语言，主要用于统计分析、绘图、数据挖掘。</p>
<blockquote>
<p>尽管很不情愿学习R，甚至连助教也表示自己不会R更倾向于用py处理数据，但是为了所谓的“与国际接轨”课程还是稍微学一下吧114514</p>
<p>毕竟作为一名成熟的cv(ctrl cv)工程师，应该要能在短时间上手一门语言</p>
</blockquote>
<span id="more"></span>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><strong>基本的三种数据类型</strong></p>
<ul>
<li><p>数字</p>
<p>分为一般型（123）与科学计数法（1.23e2）</p>
</li>
<li><p>逻辑</p>
<p><strong>TRUE</strong> 和 <strong>FALSE</strong>，R语言区分大小写</p>
</li>
<li><p>文本</p>
<p>与字符串差不多，可以用单引号定义</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;r&#x27;</span><span class="operator">==</span><span class="string">&quot;r&quot;</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="literal">TRUE</span></span><br></pre></td></tr></table></figure>

<p>有一说一，这种‘放纵’的风格我不太喜欢</p>
</li>
</ul>
<p><strong>按对象类型分-六种</strong></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/07/52988954-D570-42FD-9CFC-90CD78D361C3.jpg" alt="借用一下菜鸟的图"></p>
<h2 id="向量-vector"><a href="#向量-vector" class="headerlink" title="向量-vector"></a>向量-vector</h2><p>向量从数据结构上看就是一个线性表，可以看成一个数组。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">b <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span></span><br><span class="line">a<span class="operator">+</span>b</span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">8</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><code>c()</code>函数的作用是创建一个向量，可以看到向量可以直接相加，有len的限制，不一致会Panic。</p>
<h3 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h3><p><strong>下标</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">,</span><span class="number">30</span>，<span class="number">40</span>，<span class="number">50</span><span class="punctuation">)</span></span><br><span class="line">a<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>R中的下标不是偏移量而是第几个</p>
<p><strong>取一部分</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">取一段</span><br><span class="line">a<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span></span><br><span class="line">取某几个</span><br><span class="line">a<span class="punctuation">[</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">10</span> <span class="number">30</span> <span class="number">50</span></span><br><span class="line">不取某几个</span><br><span class="line">a<span class="punctuation">[</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">3</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">20</span> <span class="number">40</span></span><br></pre></td></tr></table></figure>

<p><strong>标量运算</strong></p>
]]></content>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>todolist-2023</title>
    <url>/2023/01/01/todolist-2023/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>全局唯一标识分区表GPT</title>
    <url>/2022/04/08/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E5%88%86%E5%8C%BA%E8%A1%A8GPT/</url>
    <content><![CDATA[<h1 id="给老师们换个大房子"><a href="#给老师们换个大房子" class="headerlink" title="给老师们换个大房子"></a>给老师们换个大房子</h1><blockquote>
<p>小明一直以来都致力于支持一线老师们的演艺事业，多年来存下来超多的演艺资源。</p>
<p>这也导致老师们纷纷抱怨道，现在的房子太小，太拥挤。于是小明购入了一块4T的硬盘，可是装上硬盘以后坏了。原本4T的硬盘现在只有2T的使用率，完蛋，这个问题不解决的话老师们住哪里?</p>
</blockquote>
<span id="more"></span>

<p>MBR系统中通过四个字节来表明分区的扇区总数，经过计算可以得知，以512字节的扇区为基准。MBR系统所支持的最大磁盘容量是2T。</p>
<p>如何突破这一上线？</p>
<p>通过刚才对计算我们可以推出：最大容量 &#x3D; 最大扇区数 ✖️ 扇区大小</p>
<p>想要提高最大容量就可以从这两方面入手。</p>
<h2 id="扇区大小"><a href="#扇区大小" class="headerlink" title="扇区大小"></a>扇区大小</h2><p>根据几个古早的规定协议，扇区的大小被约定为512字节</p>
<blockquote>
<p>1956年由industry trade organization, International Disk Drive Equipment和Materials Association三家机构确定的行业标准</p>
<p>有时代和技术的限制，因为磁盘技术发展初期，存储容量非常小。512字节的扇区也够用，但是随着时代的发展，512字节大小的扇区（Sector）明显太小了，由于每个扇区（Sector）还要存放很多其他信息，因此增大sector size可以降低扇区（Sector）的数量，从而提高实际存储量，同时降低了差错校验等很多CPU计算量。但遗憾的是<strong>由于这个标准太根深蒂固，要想改变一些底层代码或架构势必非常困难，所以现在4KB扇区硬盘暂时还没有全部普及</strong>。</p>
</blockquote>
<p>现在市面上2T以上的硬盘基本上都是以4KB做为扇区大小。</p>
<p>你也可以通过简单的指令查看自己的硬盘的情况，以macos举例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">diskutil list</span><br><span class="line">diskutil info &#123;location of your disk&#125;</span><br><span class="line"></span><br><span class="line">Device Block Size:         512 Bytes</span><br></pre></td></tr></table></figure>

<h2 id="扇区数"><a href="#扇区数" class="headerlink" title="扇区数"></a>扇区数</h2><p>MBR系统有四个字节用于表明扇区数量，也就是2^32。毫无疑问要突破这种限制我们需要一个新的系统</p>
<blockquote>
<p>全局唯一标识分区表（GUID Partition Table，缩写：GPT）是指全局唯一标示磁盘分区表格式。它是可扩展固件接口（EFI）标准（被Intel用于替代个人计算机的BIOS）的一部分，<strong>被用于替代BIOS系统中的以32bits来存储逻辑块地址和大小信息的主引导记录（MBR）分区表</strong>。</p>
</blockquote>
]]></content>
      <tags>
        <tag>磁盘</tag>
      </tags>
  </entry>
  <entry>
    <title>fyne</title>
    <url>/2024/01/16/fyne/</url>
    <content><![CDATA[<h1 id="fyne"><a href="#fyne" class="headerlink" title="fyne"></a>fyne</h1><h2 id="fyne包结构划分"><a href="#fyne包结构划分" class="headerlink" title="fyne包结构划分"></a>fyne包结构划分</h2><p><code>fyne</code>将功能划分到多个子包中：</p>
<ul>
<li><code>fyne.io/fyne</code>：提供所有<code>fyne</code>应用程序代码共用的基础定义，包括数据类型和接口；</li>
<li><code>fyne.io/fyne/app</code>：提供创建应用程序的 API；</li>
<li><code>fyne.io/fyne/canvas</code>：提供<code>Fyne</code>使用的绘制 API；</li>
<li><code>fyne.io/fyne/dialog</code>：提供对话框组件；</li>
<li><code>fyne.io/fyne/layout</code>：提供多种界面布局；</li>
<li><code>fyne.io/fyne/widget</code>：提供多种组件，<code>fyne</code>所有的窗体控件和交互元素都在这个子包中。</li>
</ul>
<span id="more"></span>

<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>在<code>fyne</code>应用程序中，所有显示元素都是绘制在画布（<code>Canvas</code>）上的。这些元素都是画布对象（<code>CanvasObject</code>）。调用<code>Canvas.SetContent()</code>方法可设置画布内容。<code>Canvas</code>一般和布局（<code>Layout</code>）容器（<code>Container</code>）一起使用。<code>canvas</code>子包中提供了一些基础的画布对象：</p>
<h3 id="元素挂载到画布上"><a href="#元素挂载到画布上" class="headerlink" title="元素挂载到画布上"></a>元素挂载到画布上</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := container.New(layout.NewGridLayout(<span class="number">1</span>), rect, text, line, circle, image, raster, gradient)</span><br><span class="line">w.SetContent(c)</span><br></pre></td></tr></table></figure>

<h2 id="CanvasObject"><a href="#CanvasObject" class="headerlink" title="CanvasObject"></a>CanvasObject</h2><h3 id="Rectangle矩形"><a href="#Rectangle矩形" class="headerlink" title="Rectangle矩形"></a>Rectangle矩形</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">canvas.NewRectangle(color.Black)</span><br></pre></td></tr></table></figure>

<h3 id="Text-文本"><a href="#Text-文本" class="headerlink" title="Text 文本"></a>Text 文本</h3><p><strong>对齐方式</strong></p>
<ul>
<li><code>TextAlignLeading</code>：左对齐；</li>
<li><code>TextAlignCenter</code>：中间对齐；</li>
<li><code>TextAlignTrailing</code>：右对齐。</li>
</ul>
<p><strong>字体样式</strong></p>
<p>通过设置<code>Text</code>对象的<code>TextStyle</code>字段值，<code>TextStyle</code>是一个结构体：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">type TextStyle struct &#123;</span><br><span class="line">  Bold      bool</span><br><span class="line">  Italic    bool</span><br><span class="line">  Monospace bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Bold</code>：粗体；</li>
<li><code>Italic</code>：斜体；</li>
<li><code>Monospace</code>：系统等宽字体。</li>
</ul>
<p><strong>外部字体</strong></p>
<p>通过设置环境变量<code>FYNE_FONT</code>为一个<code>.ttf</code>文件从而使用外部字体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">text := canvas.NewText(<span class="string">&quot;Hello Text&quot;</span>, color.Black)</span><br><span class="line"></span><br><span class="line">text.Alignment = fyne.TextAlignTrailing</span><br><span class="line">text.TextStyle = fyne.TextStyle&#123;Italic: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Line线"><a href="#Line线" class="headerlink" title="Line线"></a>Line线</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">line := canvas.NewLine(color.Black)</span><br><span class="line"></span><br><span class="line">line.StrokeWidth = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="Circle圆"><a href="#Circle圆" class="headerlink" title="Circle圆"></a>Circle圆</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">circle := canvas.NewCircle(color.Black)</span><br><span class="line"></span><br><span class="line">circle.StrokeColor = color.Gray&#123;<span class="number">0x99</span>&#125;</span><br><span class="line">circle.StrokeWidth = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="ImageFromResource图像"><a href="#ImageFromResource图像" class="headerlink" title="ImageFromResource图像"></a>ImageFromResource图像</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">image := canvas.NewImageFromResource(theme.FileIcon())</span><br><span class="line">image.FillMode = canvas.ImageFillOriginal</span><br></pre></td></tr></table></figure>

<h3 id="RasterWithPixels栅格与像素"><a href="#RasterWithPixels栅格与像素" class="headerlink" title="RasterWithPixels栅格与像素"></a>RasterWithPixels栅格与像素</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">raster := canvas.NewRasterWithPixels(</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(_, _, w, h <span class="type">int</span>)</span></span> color.Color &#123;</span><br><span class="line">       <span class="keyword">return</span> color.RGBA&#123;<span class="type">uint8</span>(rand.Intn(<span class="number">255</span>)),</span><br><span class="line">          <span class="type">uint8</span>(rand.Intn(<span class="number">255</span>)),</span><br><span class="line">          <span class="type">uint8</span>(rand.Intn(<span class="number">255</span>)), <span class="number">0xff</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="Gradient渐变图"><a href="#Gradient渐变图" class="headerlink" title="Gradient渐变图"></a>Gradient渐变图</h3><p><strong>HorizontalGradient水平线性渐变</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gradient := canvas.NewHorizontalGradient(color.Black, color.Transparent)</span><br></pre></td></tr></table></figure>

<p><strong>VerticalGradient垂直线性渐变</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gradient := canvas.NewRadialGradient(color.Black, color.Transparent)</span><br></pre></td></tr></table></figure>

<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>窗体控件是一个<code>Fyne</code>应用程序的主要组成部分。它们能适配当前的主题，并且处理与用户的交互。</p>
<h3 id="Label标签"><a href="#Label标签" class="headerlink" title="Label标签"></a>Label标签</h3><p>标签（<code>Label</code>）用于显示字符串。</p>
<p>它有点类似于<code>canvas.Text</code>，不同之处在于<code>Label</code>可以处理简单的格式化比如’\n’</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">label := widget.NewLabel(<span class="string">&quot;Name&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Button按钮"><a href="#Button按钮" class="headerlink" title="Button按钮"></a>Button按钮</h3><p>按钮（<code>Button</code>）控件让用户点击，给用户反馈。</p>
<p><code>Button</code>可以包含文本，图标或两者皆有。</p>
<p>调用<code>widget.NewButton()</code>创建一个默认的文本按钮，传入文本和一个无参的回调函数。</p>
<p>带图标的按钮需要调用<code>widget.NewButtonWithIcon()</code>，传入文本和回调参数，还需要一个<code>fyne.Resource</code>类型的图标资源：</p>
<h3 id="Entry输入框"><a href="#Entry输入框" class="headerlink" title="Entry输入框"></a>Entry输入框</h3><p>输入框（<code>Entry</code>）控件用于给用户输入简单的文本内容。</p>
<p>调用<code>widget.NewEntry()</code>即可创建一个输入框控件。</p>
<p><strong>我们一般保存输入框控件的引用，以便访问其<code>Text</code>字段来获取内容。</strong></p>
<ul>
<li><p>注册<code>OnChanged</code>回调函数。每当内容有修改时，<code>OnChanged</code>就会被调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nameEntry.OnChanged = <span class="function"><span class="keyword">func</span><span class="params">(content <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;name:&quot;</span>, nameEntry.Text, <span class="string">&quot;entered&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>调用<code>SetReadOnly(true)</code>设置输入框的只读属性。</del></p>
</li>
<li><p><code>SetPlaceHolder()</code>用来设置占位字符串。</p>
</li>
<li><p>设置字段<code>Multiline</code>让输入框接受多行文本。</p>
</li>
<li><p>使用<code>NewPasswordEntry()</code>创建一个密码输入框，输入的文本不会以明文显示。</p>
</li>
</ul>
<p>通常将Button与Entry结合使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">input := widget.NewEntry()</span><br><span class="line">input.SetPlaceHolder(<span class="string">&quot;Enter text...&quot;</span>)</span><br><span class="line">content := container.NewVBox(input, widget.NewButton(<span class="string">&quot;Save&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;Content was:&quot;</span>, input.Text)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>



<h3 id="Choices-选择框"><a href="#Choices-选择框" class="headerlink" title="Choices 选择框"></a>Choices 选择框</h3><p><code>Check</code>是简单的选择框，每个选择是独立的，例如爱好可以是足球、篮球，也可以都是。创建方法<code>widget.NewCheck()</code>，传入选项字符串（足球，篮球）和回调函数。</p>
<p>回调函数接受一个<code>bool</code>类型的参数，表示该选项是否选中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">football := widget.NewCheck(<span class="string">&quot;football&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(value <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;football:&quot;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line">basketball := widget.NewCheck(<span class="string">&quot;basketball&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(value <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;basketball:&quot;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line">pingpong := widget.NewCheck(<span class="string">&quot;pingpong&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(value <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;pingpong:&quot;</span>, value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>CheckGroup</code>支持由字符串切片快速生成多个选择框，回调函数接受一个<code>[]string</code>类型的参数，为当前所有勾选的<code>Group</code>内的选项</p>
<p><code>RadioGroup</code>是单选框，每个组内只能选择一个，例如性别，只能是男或女（？）。创建方法<code>widget.NewRadioGroup()</code>，传入字符串切片和回调函数作为参数。回调函数接受一个字符串参数，表示选中的选项。也可以使用<code>Selected</code>字段读取选中的选项。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sexRadioGroup := widget.NewRadioGroup([]<span class="type">string</span>&#123;<span class="string">&quot;male&quot;</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;unknown&quot;</span>&#125;, <span class="function"><span class="keyword">func</span><span class="params">(value <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sex:&quot;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line">sexBox := container.NewHBox(widget.NewLabel(<span class="string">&quot;Sex&quot;</span>), sexRadioGroup)</span><br></pre></td></tr></table></figure>



<p><code>Select</code>是下拉选择框，点击时显示一个下拉菜单，点击选择。选项非常多的时候，比较适合用<code>Select</code>。创建方法<code>widget.NewSelect()</code>，参数与<code>NewRadio()</code>完全相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">provinceSelect := widget.NewSelect([]<span class="type">string</span>&#123;<span class="string">&quot;anhui&quot;</span>, <span class="string">&quot;zhejiang&quot;</span>, <span class="string">&quot;shanghai&quot;</span>&#125;, <span class="function"><span class="keyword">func</span><span class="params">(value <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;province:&quot;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line">provinceBox := container.NewHBox(widget.NewLabel(<span class="string">&quot;Province&quot;</span>), layout.NewSpacer(), provinceSelect)</span><br></pre></td></tr></table></figure>

<h3 id="From表单"><a href="#From表单" class="headerlink" title="From表单"></a>From表单</h3><p>表单控件（<code>Form</code>）用于对很多<code>Label</code>和输入控件进行布局。</p>
<p>如果指定了<code>OnSubmit</code>或<code>OnCancel</code>函数，表单控件会自动添加对应的<code>Button</code>按钮。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">form.OnSubmit = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;name:&quot;</span>, nameEntry.Text, <span class="string">&quot;pass:&quot;</span>, passEntry.Text, <span class="string">&quot;login in&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">form.OnCancel = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;login canceled&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们调用<code>widget.NewForm()</code>传入一个<code>widget.FormItem</code>切片创建<code>Form</code>控件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">form := widget.NewForm(</span><br><span class="line">	&amp;widget.FormItem&#123;Text: <span class="string">&quot;Name&quot;</span>, Widget: nameEntry&#125;,</span><br><span class="line">	&amp;widget.FormItem&#123;Text: <span class="string">&quot;Pass&quot;</span>, Widget: passEntry&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>&amp;widget.Form&#123;&#125;</code>创建</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">form := &amp;widget.Form&#123;</span><br><span class="line">	Items: []*widget.FormItem&#123; <span class="comment">// we can specify items in the constructor</span></span><br><span class="line">		&#123;Text: <span class="string">&quot;Entry&quot;</span>, Widget: entry&#125;&#125;,</span><br><span class="line">	OnSubmit: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// optional, handle form submission</span></span><br><span class="line">		log.Println(<span class="string">&quot;Form submitted:&quot;</span>, entry.Text)</span><br><span class="line">		log.Println(<span class="string">&quot;multiline:&quot;</span>, textArea.Text)</span><br><span class="line">		myWindow.Close()</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一项中一个字符串作为<code>Label</code>的文本，一个控件对象。</p>
<p><del>创建好<code>Form</code>对象之后还能调用其<code>Append(label, widget)</code>方法添加控件。</del>有bug导致<code>OnSubmit</code>或<code>OnCancel</code>函数不起作用，最好在New表单的时候就指定完所有的控件。</p>
<h3 id="ProgressBar进度条控件"><a href="#ProgressBar进度条控件" class="headerlink" title="ProgressBar进度条控件"></a>ProgressBar进度条控件</h3><p>进度条控件（<code>ProgressBar</code>）用来表示任务的进度。</p>
<p>创建方法<code>widget.NewProgressBar()</code>，默认最小值为<code>0.0</code>，最大值为<code>1.1</code>，可通过<code>Min/Max</code>字段设置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bar := widget.NewProgressBar()</span><br><span class="line"></span><br><span class="line">bar.Min = <span class="number">0</span></span><br><span class="line">bar.Max = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>调用<code>SetValue()</code>方法来控制进度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bar.SetValue(<span class="type">float64</span>(i))</span><br></pre></td></tr></table></figure>

<p>还有一种进度条是循环动画，它表示有任务在进行中，并不能表示具体的完成情况。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bar := widget.NewProgressBarInfinite()</span><br></pre></td></tr></table></figure>



<h2 id="容器和布局"><a href="#容器和布局" class="headerlink" title="容器和布局"></a>容器和布局</h2><h3 id="Box盒子"><a href="#Box盒子" class="headerlink" title="Box盒子"></a>Box盒子</h3><p>盒子控件（<code>Box</code>）就是一个简单的水平或垂直的容器。</p>
<p>在内部，<code>Box</code>对子控件采用盒状布局（<code>Box Layout</code>）。</p>
<p><del>我们可以通过传入控件对象给<code>widget.NewHBox()</code>或<code>widget.NewVBox()</code>创建盒子。</del></p>
<p><del>或者调用已经创建好的<code>widget.Box</code>对象的<code>Append()</code>或<code>Prepend()</code>向盒子中添加控件。前者在尾部追加，后者在头部添加。</del></p>
<p>它有两种变体，水平和垂直。方框布局将所有元素排列在一行或一列中，并带有可选的空格以帮助对齐。</p>
<p>用layout创建的水平框布局。NewHBoxLayout（）创建单行中项目的排列。框中的每个项目都将其宽度设置为其MinSize（）。所有项目的宽度和高度都将相等，这是所有MinSize（）.height值中的最大值。布局可以在容器中使用，也可以使用box小部件。NewHBox（）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">content := container.New(</span><br><span class="line">    layout.NewHBoxLayout(),</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">content := container.NewHBox()</span><br></pre></td></tr></table></figure>

<p>垂直框布局类似，但它在列中排列项目。每个项目的高度将设置为最小值，所有宽度将相等，设置为最小宽度中的最大值。</p>
<p>要在元素之间创建扩展空间（例如，使一些元素左对齐，另一些元素右对齐），请添加layout.NewSpacer（）作为其中一项。间隔件将展开以填充所有可用空间。在垂直框布局的开头添加间隔符将导致所有项目底部对齐。您可以在水平排列的起点和终点添加一个，以创建中心对齐。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">centered := container.New(layout.NewHBoxLayout(), layout.NewSpacer(), text4, layout.NewSpacer())</span><br></pre></td></tr></table></figure>



<h3 id="TabContainer标签容器"><a href="#TabContainer标签容器" class="headerlink" title="TabContainer标签容器"></a>TabContainer标签容器</h3><p>标签容器（<code>TabContainer</code>）允许用户在不同的内容面板之间切换。</p>
<p>标签可以是文本或图标。</p>
<p>使用<code>container.NewAppTabs</code>（…）和传递<code>container.TabItem</code>项（可以使用<code>container.NewTabItem（…）</code>创建）创建选项卡容器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tabs := container.NewAppTabs(</span><br><span class="line">    container.NewTabItem(<span class="string">&quot;Profile&quot;</span>, profile),</span><br><span class="line">    container.NewTabItem(<span class="string">&quot;Setting&quot;</span>, setting),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以通过设置选项卡的位置来配置选项卡容器，默认位置为top。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tabs.SetTabLocation(container.TabLocationBottom)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>container.TabLocationTop</code></li>
<li><code>container.TabLocationBottom</code></li>
<li><code>container.TabLocationLeading</code></li>
<li><code>container.TabLocationTrailing</code></li>
</ul>
<h2 id="theme"><a href="#theme" class="headerlink" title="theme"></a>theme</h2><p>家园图标</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">theme.HomeIcon()</span><br></pre></td></tr></table></figure>

<h2 id="活动流程"><a href="#活动流程" class="headerlink" title="活动流程"></a>活动流程</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := app.New()</span><br><span class="line">w := a.NewWindow(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//type1</span></span><br><span class="line">w.ShowAndRun()</span><br><span class="line"></span><br><span class="line"><span class="comment">//type2</span></span><br><span class="line">w.Show()</span><br><span class="line">a.Run()</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <tags>
        <tag>fyne</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机是如何启动的?</title>
    <url>/2022/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E7%9A%84/</url>
    <content><![CDATA[<blockquote>
<p>“pull oneself up by one’s bootstraps”</p>
</blockquote>
<span id="more"></span>

<h1 id="why-boot"><a href="#why-boot" class="headerlink" title="why boot?"></a>why boot?</h1><p>reboot，在我刚接触linux的时候学到了这个命令。boot，意味启动，原意为靴子。</p>
<p><strong>靴子跟启动是怎么联系起来的呢？</strong></p>
<p>boot实际上是bootstrap（鞋子背带）的缩写。</p>
<blockquote>
<p>“pull oneself up by one’s bootstraps”最初来自于《The Surprising Adventures of Baron Munchausen》这本书里的一个故事：主人公Baron Munchausen不小心掉进了一片沼泽，他通过自己的bootstraps将自己拉了出来。事实上在19世纪初美国就有”pull oneself over a fence by one’s bootstraps”的语言，意思是“做荒谬不可能完成的事情”。</p>
</blockquote>
<p>计算机的启动时一个矛盾的过程：必须先运行程序，才能启动计算机，但是计算机不启动的话就无法运行程序。</p>
<p>早期的时候，工程师们想尽各种办法，把一段程序先装进内存，然后计算机才能正常启动。这个过程被比喻为为拉鞋带（bootstrap）。</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>无论是在可视化界面中进行点击，还是在命令行中输入命令来执行程序，实际上在一个已经运行中的操作系统中执行程序。那么在开机加电的一瞬间，内存中是没有程序的，更不用说操作系统，所以我们不可能从软件的角度去执行BIOS，那么就只能从硬件的角度去分析。</p>
<p>CPU硬件逻辑设计为加电瞬间将代码段寄存器（CS）的值设置为0xFFFF，偏移量(IP)的值置为0x0000，这样CS:IP就指向了0xFFFF0这个地址上，这也是BIOS程序第一条指令所在的位置。</p>
<p>上述过程是一个纯硬件完成的动作，如果这个地址没有可执行的代码，那么计算机将什么也不做并陷入死机，反之如果有可执行的代码，则将从这个代码开始沿着后续的程序一直执行下去。</p>
<blockquote>
<p>上世纪70年代，只读内存ROM（read-only memory）被发明出来，开机程序被刷入ROM芯片中</p>
<p>计算机通电以后，干的第一件事情就是去读取它。</p>
<p>这块芯片中的程序被称为 基本输出输入系统（basic input&#x2F;output system），也就是简称后的BIOS。</p>
</blockquote>
<blockquote>
<p>BIOS程序被固化在计算机主机板上的一块很小的ROM芯片里。通常，不同的主机板所用的BIOS也有所不同，就启动部分而言，各种类型的BIOS的基本原理大致相似。随着BIOS程序的执行，屏幕上会显示显卡的信息、内存的信息……说明BIOS程序在检测显卡、内存……这期间，有一项对启动（boot）操作系统至关重要的工作，那就是BIOS在内存中建立中断向量表和中断服务程序。</p>
<p>中断向量是指早期的微机系统中将由硬件产生的中断标识码（中断源的识别标志，可用来形成相应的中断服务程序的入口地址或存放中断服务程序的首地址）。中断是指在计算机执行程序的过程中，当出现异常情况或者特殊请求时，计算机停止现行的程序的运行，转而对这些异常处理或者特殊请求的处理，处理结束后再返回到现行程序的中断处，继续执行原程序。</p>
<p>中断向量表中有256个中断向量，每个中断向量占4个字节，其中两个字节是代码段寄存器（CS）的值，两个字节是偏移量（IP）的值，每个中断向量都指向一个具体的中断服务程序。现在，可以先将中断理解为一种技术手段，在这一点上与C语言的函数调用有些类似。</p>
</blockquote>
<p>BIOS被读取之后干了这么几件事</p>
<ol>
<li><p><strong>硬件自检</strong></p>
<p>BIOS先对计算机硬件进行检查以确保其能满足计算机的运行条件，称为 硬件自检POST（Power-On Self-Test）。</p>
</li>
<li><p><strong>基于启动顺序移交控制权</strong></p>
<p>在硬件自检后，BIOS需要将控制权交给下一阶段的启动程序。</p>
<p>交给谁，交到哪。BIOS需要一个外部存储设备的排序，排在前的设备就是优先转交控制权的设备。这种排序被称为 启动顺序（Boot Sequence）</p>
</li>
</ol>
<h2 id="主引导记录"><a href="#主引导记录" class="headerlink" title="主引导记录"></a>主引导记录</h2><p>BIOS按照启动顺序将控制权移交给排在第一位的存储设备。</p>
<p>计算器去读取这个设备的第一个扇区（最前面的512个字节）。如果这512个字节的最后两个字节是0x55与0xAA，则表示这个设备可以用于启动，如果不是则控制权顺序移交至下一位。</p>
<p>这512个字节，称为 主引导记录（Master boot record）,是采用MBR分区表的硬盘的第一个扇区。</p>
<p>主引导记录的主要作用是:告诉计算机到硬盘的哪一个位置去寻找操作系统。</p>
<p>主引导记录分为三部分</p>
<ul>
<li>1-446字节：调用操作系统的机械码</li>
<li>447-510字节：分区表（Partition table）</li>
<li>511-512字节：主引导签名（0x55，0xAA）</li>
</ul>
<p>分区表的作用是将硬盘分成若干个区，分区表的长度为64个字节，其又分成四项，每项16个字节。一个硬盘最多分为四个一级区，也叫做主分区。</p>
<p>每个分区是16个字节，由六个部分组成：</p>
<ul>
<li>1字节：如果为0x80，则表明该分区是激活分区，控制权将交由该分区。四个主分区中只能有一个是激活的</li>
<li>2-4字节：主分区第一个扇区的物理位置（柱面，磁头，扇区号等等）</li>
<li>5字节：主分区类型</li>
<li>6-8字节：主分区最后一个扇区的物理位置。</li>
<li>9-12字节：该主分区第一个扇区的逻辑地址</li>
<li>13-16字节：主分区的扇区总数</li>
</ul>
<p>由四个字节决定了扇区总数，一个字节八个bit，也就是扇区的总数最多是2的32次方（4294967296），按照每个扇区是512个字节，即最多存储2199023255552个字节,也就是2147483648kb,2097152mb,2048GB,2TB。</p>
<h2 id="硬盘启动"><a href="#硬盘启动" class="headerlink" title="硬盘启动"></a>硬盘启动</h2><p>计算机的控制权将交由硬盘的某个分区，又可分成三种情况</p>
<ul>
<li><p>卷引导记录VBR（Volume boot record）</p>
<p>四个主分区只有一个分区是激活的，计算机会读取激活分区的第一个扇区，称为卷引导记录VBR。</p>
<p>卷引导记录的作用是告诉计算机，操作系统在这个分区的位置，然后计算机就会去加载操作系统。</p>
</li>
<li><p>扩展分区与逻辑分区</p>
<p>当四个主分区不足时，我们需要更多的分区。但是分区表仅有四项，因此规定有且仅有一个区可以被定义为 扩展分区（Extended partition）。</p>
<p>扩展分区中又分成多个区，这种区称为逻辑分区（logical partition）。</p>
<p>计算机先读取扩展分区的第一个扇区，扩展引导记录EBR（extended boot record）。其内有一张64字节的分区表，但是最多只有两项（即两个逻辑分区）。</p>
<p>再读取第二个逻辑分区的第一个扇区从其的分区表中找出第三个逻辑分区的位置，以此类推知道某个逻辑分区的分区表只包含它自身。</p>
</li>
<li><p>启动管理器(boot loader)</p>
<p>在计算机读取主引导记录前446字节的机械码之后，不再将控制权移交给某一个分区，而是运行启动管理器，由用户选择启动哪一个操作系统。</p>
</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>控制权交由操作系统后，操作系统的内核首先被载入内存。</p>
<p>如Linux，内核载入成功后，运行&#x2F;sbin&#x2F;init，其根据配置文件产生init进程，pid为1。然后init线程加载系统的各个模块，直至执行&#x2F;bin&#x2F;login，跳出登陆界面，由用户输入账号密码。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的？ - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
<p><a href="https://blog.csdn.net/weixin_43590389/article/details/104094234"></a></p>
]]></content>
  </entry>
  <entry>
    <title>代码规范</title>
    <url>/2022/05/31/%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="head-of-a-go-file"><a href="#head-of-a-go-file" class="headerlink" title="head of a go file"></a>head of a go file</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @program:     $&#123;PROJECT_NAME&#125;</span><br><span class="line">// @file:        $&#123;FILE_NAME&#125;</span><br><span class="line">// @author:      sun sun</span><br><span class="line">// @create:      $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line">// @description: </span><br><span class="line"></span><br><span class="line">package $&#123;GO_PACKAGE_NAME&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
